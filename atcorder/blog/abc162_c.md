# abc162_c
## 考えたこと 
一瞬面食らったがよくよく見たら (1,1,1) ~ (k,k,k) の K^3 パターンの数の組み合わせの最大公約数を全部足せということが分かった。

3 重ループで実装するのは簡単そうだが、さてそんな簡単な問題が出るだろうか…？と思い制約を見ると、
```
k <= 200
```
 となっていた。

普通に考えれば 200^3 = 8 * 10^6 < 10^8 なので、gcd のアルゴリズムがによってはギリギリと考えるも、まずは愚直に実装。
```
import math
from functools import reduce
def gcd(*numbers):
    return reduce(math.gcd, numbers)

K = int(input())
ans = 0
for i in range(1,K+1):
    for j in range(1,K+1):
        for k in range(1,K+1):
            ans += gcd(i,j,k)
print(ans)
```
手元で最大値の200を入れて実行すると、大体5秒～7秒程度の時間で、少し間に合わない状態。

ここから、
1. `重複パターンをいかに減らすか` ( (2,3,4）と (3,2,4)   は同じ結果なので1回で済ませる )、 
2. `計算する必要ないところは計算しない` （1が含まれたら必ず1になる、など）というのをいろいろ考えていきました。

しかしこれらの戦略でそもそも正答しなくなったりエラーになったりとバグに苦しんだので、pypy でとりあえず今できている最低限のものだけで回答し、それが AC となりました。


## 参考
回答をする際には参考にしたところはなかったですが、記事を書くうえで、けんちょんさんの計算量の記事（ https://qiita.com/drken/items/872ebc3a2b5caaa4a0d0 ）を参考にさせていただきました。

## 感想
ローカルの環境だと 5 秒くらい時間がかかってしまったので日和って色々と計算を少なくできないか検討していた（1 が含まれてたら 100％ 1 が最大公約数だから計算しない、など）がなかなかローカル環境では 2 秒にならず、1回あきらめて pypy で提出してみたところ何事もなく通った…

コンテスト後に最初に記載している単純な 3 重ループが python3 では通らず pypy では通ることも確認したので、かなり時間のロスをした感が…（これだったら数分程度で提出できた気がする…）

これに関しては、自分が計算量の感覚がなかったことや、コードテストで最初に python と pypy 試せばよかったということで、これも含めてコンテストの結果として受け止めて、今後の学びにしたいです。


ちなみに gcd の計算量は 小さいほうの数の桁数*5 程度とのこと?（ https://ja.wikipedia.org/wiki/%E3%83%A6%E3%83%BC%E3%82%AF%E3%83%AA%E3%83%83%E3%83%89%E3%81%AE%E4%BA%92%E9%99%A4%E6%B3%95#%E8%A8%88%E7%AE%97%E9%87%8F ）なのでこれを機にここら辺の勉強もしたいと思いました。

