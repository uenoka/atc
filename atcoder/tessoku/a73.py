
'''
# 問題

ALGO 市には $N$ 個の交差点と $M$ 本の道路があります。$i$ 本目の道路は、交差点 $A\_i$ と交差点 $B\_i$ を双方向に結んでおり、長さは $C\_i$ メートルです。交差点どうしは、いくつかの道路を通って必ず行き来できることが保証されます。また、 $D\_i = 1$ であるような道路には、木が一本植えられています。

ALGO 市の市長である次郎君は、交差点 $1$ と交差点 $N$ を結ぶマラソンコースを作ろうと思いました。彼は参加者を疲れさせたくないので、合計距離をできるだけ短くしたいです。また参加者に自然を楽しんでいただきたいので、合計距離が同じ場合、コース上に植えられている木の数をより多くしたいです。どのようなマラソンコースが考えられますか。

# 考察

グラフの問題
重みのある非有向グラフ(もしくは双方向に同じ重みがある有向グラフとも言えるか)
交差点どうしは、いくつかの道路を通って必ず行き来できることが保証されます。→連結であることが保証されている
Di=1の場合木がある、同じ距離の場合木があるほうが優先される。
1からNまでの最短ルートかつ、同じ距離の場合木が多いルートを選ぶ
出力は距離と木の本数
ダイクストラをどうにか改良すれば行けないか?
え、解説読んじゃったけど、木があるとき優先度を少しだけ上げるという方法でいいらしい。なるほど。0.0001とか。
'''
import heapq

def dijkstra(s):
    hq = [(0, s)]
    heapq.heapify(hq) # リストを優先度付きキューに変換
    cost = [float('inf')] * n # 行ったことのないところはinf
    cost[s] = 0 # 開始地点は0
    while hq:
        c, v = heapq.heappop(hq)
        if c > cost[v]: # コストが現在のコストよりも高ければスルー
            continue
        for d, u in e[v]:
            tmp = d + cost[v]
            if tmp < cost[u]:
                cost[u] = tmp
                heapq.heappush(hq, (tmp, u))
    return cost

n,m = map(int,input().split())
e = [[] for _ in range(n)]
for _ in range(m):
    a,b,c,d = map(int,input().split())
    c *= 10000
    c -= d
    a,b = a-1, b-1
    e[a].append((c, b))
    e[b].append((c, a))

dist = dijkstra(0)
print((dist[n-1]+dist[n-1]%10000)//10000, 10000 - dist[n-1]%10000)

