'''
# 問題

下図のような $N$ 段のピラミッドがあり、最下段には左から順に整数 $A\_1,A\_2,\dots,A\_N$ が書かれています。また、最上段には $1$ つのコマが置かれています。\
太郎君と次郎君は、このピラミッドを使ってゲームをします。コマが最下段に到達するまで、各プレイヤーは交互に以下のいずれかの操作を行います（太郎君が先手です）。

* コマを左下方向に $1$ つ移動させる。
* コマを右下方向に $1$ つ移動させる。

ゲーム終了時のコマの位置に書かれた整数を **スコア** とします。太郎君はスコアを最大化し、次郎君はスコアを最小化するとき、スコアはいくつになりますか。

![](https://img.atcoder.jp/tessoku-book-pre/a376b66ab093bbfd1984e3dc28691411.png)

# 考察

先手後手で最大、最小に少しでも近づくように動く、という動作をする。
ただし、おそらくフェーズが後ろに行くにつれて到達可能範囲が狭まるから、それによって段々と行く方向が変わる。
あれ、相手の手を考慮したうえで自分の手をやらないといけない?
例えば、最下段が
100,2,20,30,1
となっているときに、相手は100に動こうとするから1は狙わずに2を狙いに行くのが後手の最適解になる可能性。
そうすると手が変わってきそう。
したから順に、ひとつ下の最大 or 最小を見ていくのが最適解。
なるほど、先手後手があるから、こうするのがやりやすい(1つ上はしたの2つしか移動できないので。)
たぶん、上から順に移動するのも出来る(自身が到達可能な場所で最大はどこかを見てそっちに寄るように動かす)が、
それだと自身が到達可能な場所というのを管理するのが難しい、1つ上からみていくとそれが左右どちらかに限定できるのでやりやすい。
'''
N = int(input())
A = list(map(int,input().split()))
state = [A]
for n in range(N-1, 0, -1):
    state.append([0]*n)
minmax = N%2 # 1 : max,0 : min
for i,s in enumerate(state[1:N]):
    for j,col in enumerate(s):
        s[j] = min(state[i][j],state[i][j+1]) if minmax else max(state[i][j],state[i][j+1])
    minmax = 1 - minmax
print(state[N-1][0])