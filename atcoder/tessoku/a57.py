'''
# 問題

$N$ 個の穴がある砂場に、一匹のアリが住んでいます。このアリは規則的な動きをすることが知られており、穴 $i$（$1 \leq i \leq N$）に入った翌日には穴 $A\_i$ に移動します。

それについて、以下の $Q$ 個のクエリを処理してください。

* $j$ 個目のクエリ：いま穴 $X\_j$ にいるとき、$Y\_j$ 日後にはどの穴にいるか？

# 考察

ダブリング。
規則的な動きをするから、もとに戻るまでの回数で mod を取ってあげる
難しいのが、スタートが毎回クエリで違うのと、必ずすべての穴がつながっているわけではない(ループが別になることがある)
というのだな。
入力例の場合
7 4
2 4 1 7 6 5 3
1 1
1 5
2 13
5 999999999

クエリ1,2は割と簡単で、スタートが同じだからすぐ出来る。
ループが5回移動するともとに戻るから、[1,2,4,7,3] の配列で、mod 5 を取ることで idx 1,0 の場所にすぐ行ける。
クエリ3の場合、スタートが2つ目にいるから、[2,4,7,3,1] の配列で考えないといけない。
でもそれさえすれば、
スタート地点ごとにループ順の配列を管理するとちょっと重いかな?
毎回やらんでも同じループ内ならインデックスずらすだけでよいから楽?
同じループ内ならmodの計算を少しずらせばいいだけだからやらないほうがいいかな?
'''

N, Q = map(int, input().split())
A = list(map(int, input().split()))

# ダブリングテーブル構築
# doubling[k][i] = 穴iから2^k歩進んだ先の穴
MAX_K = 60  # 10^18 < 2^60
doubling = [[0] * (N + 1) for _ in range(MAX_K)]

# 初期化：1歩進む場合
for i in range(1, N + 1):
    doubling[0][i] = A[i - 1]

# ダブリングテーブル構築
for k in range(1, MAX_K):
    for i in range(1, N + 1):
        doubling[k][i] = doubling[k-1][doubling[k-1][i]]

def solve(x, y):
    """穴xからy歩進んだ先の穴を返す"""
    current = x
    for k in range(MAX_K):
        if (y >> k) & 1:  # yのk番目のbitが1なら
            current = doubling[k][current]
    return current

# クエリ処理
for _ in range(Q):
    x, y = map(int, input().split())
    print(solve(x, y))