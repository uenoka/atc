'''
# 問題

石の山が $N$ 個あり、山 $i(1 \le i \le N)$ には $A\_i$ 個の石が積まれています。\
このゲームでは、 $2$ 人のプレイヤーが交互に次の操作を行います。

* 好きな石の山を $1$ つ選び、選んだ山から $1$ 個以上の石を取る。

すべての石がなくなり、操作を行えなくなった方が負けです。\
両者が最善を尽くしたとき、先手と後手どちらが勝ちますか。

# 考察
具体的に考えてみる。
N = 2
A = [1,1]
このときに先手は何をやっても勝てない。
じゃあA=[1,2]のときは、先手は必ず勝てる(2つ目の山から1つだけを取って、↑の状況を作れるので)
こう考えると、A=[1,1]をいかに作り出すか、というのが肝になりそう。
では、A=[2,2]の状態はどうかというと、
先手が片方の山すべてを取ると後手が残った山をすべて取って負け、
先手が片方の山の1つだけを取ると後手が2つ石が残った山を1つ取るから負けるのでどうあがいても負ける。
ではA=[3,2]の場合だとどうなる?
先手は相手を[2,2]の状態に押し込めるので勝てる。
[3,3]だと、今度はどうあがいても先手が勝てない。[2,3]にしたら↑の方法で勝てず、[1,3]にしたら[1,1]を返されるので。
多分[3,4],[4,4],[4,5],[5,5]くらいでも同じことが言えそう。
[3,4]→先手が[3,3]を作れるので勝てる
[4,4]→先手は[3,4]を作ったら負けるので(一つ前のものになるから)、やるなら[4,2][4,1][4,0]を作る必要がある
[4,1][4,0]は確実に負けるので([4,1]は後手に[1,1]を返される、[4,0]は一つの山しかない)
考察すべきは[4,2]のみ。だけど[2,2]を作られて先手は負ける。ので必ず先手は負ける。
ではA=[100,100]の場合だとどうなる?
片方が1になった時点で、もう片方をごそっと取って[1,1]を作ればいいから自分のターンに[1,100]が来てくれると嬉しい。
でも自分のターンにこれが来る前にA2の方を減らしていくという戦略が取れるのか。
Aiが2だろうが10000だろうが、初手片方の山を2つ残しまで減らす。
ということは偶奇が関係してくる。
じゃあN=3のケースを考えてみる
[1,1,1]では、先手は必勝。なぜなら相手に[1,1]を渡せるので。
[1,1,2]でも先手は必勝。[1,1]が渡せる。
そう考えると[1,1,N]は先手必勝。
[1,2,2]も先手必勝。[2,2]を渡せる。
[1,2,3]は先手はどうあがいても勝てなそう。
なので偶奇というわけではないのかも。どういう規則性なんだろう。
(ニムだということを知ったうえで)
DPっぽく解けそうも見える。
[1,1]だと後手必勝になるのでこの状態になるように状態遷移を作っていくようなイメージ
ただ、どういうDPテーブルを用意すればいいのかというのが全然わからない。

なるほど、ニム和って書いているからすべての数字をXORするのがニムだと思ったらニム和自体がこういうゲームの必勝法なのね…
https://ja.wikipedia.org/wiki/%E3%83%8B%E3%83%A0%E5%92%8C
'''
def nim(A):
    nim = 0
    for a in A:
        nim ^= a
    return nim
N = int(input())
A = list(map(int,input().split()))
print('First' if nim(A)!=0 else 'Second')