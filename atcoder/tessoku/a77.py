
'''
# 問題

左右の長さが $L$ \[cm] のようかんがあります。 $N$ 個の切れ目が付けられており、左から $i$ 番目の切れ目は左から $A\_i$ \[cm] の位置にあります。

あなたは $N$ 個の切れ目のうち $K$ 個を選び、ようかんを $K+1$ 個のピースに分割したいです。そこで、以下の値を **スコア** とします。

* $K+1$ 個のピースのうち、最も短いものの長さ（cm 単位）

スコアが最大となるように分割する場合に得られるスコアを求めてください。

# 制約

* $1 \leq K \leq N \leq 100000$
* $0 \lt A\_1 \lt A\_2 \lt \cdots \lt A\_N \lt L \leq 10^9$
* 入力はすべて整数

# 考察

切れ目を選ぶではなく、任意の大きさに切ってK+1個にするのであれば、均等に切るのが最大になるはず。
なので、それにいかに近づけるかというのがこの問題の本質な気がする。
N、K は 10^5 以下なので、NlogN くらいは行ける。L は 10^9 なのでもしこれ使うなら O(L) くらいしかいけない。
安直に考えると均等に切ったときに一番近いのが良さそう。
でも、各 Ki(Ki はK等分するときのi個目の切れ目)が Ai とどれが近いかというのをやっていくとO(NK) で最大N^2 くらいかかる。
でもしゃくとり法的に順次進めていけばそんなにかからないかも?(Aiを使ったらAi+1以降しか使わないので。)
→ この解法だと下の入力で駄目になる
7 45
2
1 2 3 4 5 6 7
→ なぜなら、本来は3,5を選択するのが最適(2点)だが、上の方法でやると三等分した最初の切れ目の15に一番近いのは7で、その時点で破綻。
時点で近いものを選ぶ、というアルゴリズムも6,7を選択してしまう破綻。
'''
N, L = map(int,input().split())
K = int(input())
A = list(map(int,input().split()))

# L をK等分する
div = [ L/(K+1) * (i+1) for i in range(K)]
div_idx = 0
A_idx = 0
current = 0

