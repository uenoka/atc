# abc169_d
## 考えたこと 
最初は問題文を読んでも？？？となってかなり理解するのに時間がかかった。
よくよく読んでみると
```
あるzを選ぶ。
zはある素数のe乗として表せる
Nをzで割った値で置き換える
zは今まで選んだzとは重複してはいけない
```
という操作を繰り返すということがわかりました。
そこで最初はzを2からひとつづ探索して条件にあったらNを割る捜査をするという方向で実装していきました。のちにこの方法は計算量的にも処理的にも無理があったのですが、最初は問題の理解もそんなに深くなかったのでこの方向でやっていました。
コンテスト1時間経過したくらいから、この方針はもう無理だと感じ始め、少し諦めようとしました。（家事やらがまだあったので…）
しかし、よくよく問題を見ていくと、素因数分解すると N = a^m * b^n * ... と表せること、m,n...を 1+2+3... と表現することが思い浮かび、以下のような方針で回答しました。
```
N を素因数分解して、２次元配列で f = [[a,n],[b,m]...]として表現する。
それぞれの要素の２つ目の要素（m,n,...）をfor 文で-1,-2,-3....と0 になるまで引いて行って、その回数をカウントする。
カウントを答えとして出力
```
ただ、この方針でN = 1でWAとなってしまい、コーナーケースで焦りましたが、サンプルで確認してみてわかったのでだいじょうぶでした。
提出したコードは以下になります。
```

def factorization(n):
    arr = []
    temp = n
    for i in range(2, int(-(-n**0.5//1))+1):
        if temp%i==0:
            cnt=0
            while temp%i==0:
                cnt+=1
                temp //= i
            arr.append([i, cnt])
 
    if temp!=1:
        arr.append([temp, 1])
 
    if arr==[]:
        arr.append([n, 1])
 
    return arr
 
 
N = int(input())
lis = factorization(N)
ans = 0
# print(lis)
if N == 1:
    print(0)
    exit()
for i in lis:
    cnt = 1
    target = i[1]
    while target > 0:
        if target - cnt >= 0:
            ans += 1
        target -= cnt
        cnt+=1
print(ans)
```

## 計算量
Nを素因数分解するのに O(√N) , また 2^40 > 10^12 となるので、N <= 10^12であれば間に合う、ということだと思います。

## 参考
もともと素因数分解のライブラリを以前問題を解いたときに持っていたのですが、それにバグが見つかり結局ググって以下の記事を参考にしました。
https://qiita.com/snow67675476/items/e87ddb9285e27ea555f8

## 感想
この問題を結構早く解けた人は水色パフォだったのっでちょっと残念だったのですが、いろいろ試行錯誤したことで回答にたどり着けたことを考えると実力はついてきているのかなぁ、と思います。
何はともあれ茶パフォ上位をコンテスト中に解けるのはうれしい！
