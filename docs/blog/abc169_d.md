# abc169_d

## 考えたこと

最初は問題文を読んでも？？？となってかなり理解するのに時間がかかった。  
しかし、よくよく読んでみると

```txt
ある z を選ぶ。
z はある素数の e 乗として表せる
N を z で割った値で置き換える
z は今まで選んだ z とは重複してはいけない
```

という操作を繰り返すということがわかりました。
そこで最初は z を 2 からひとつづ探索して条件にあったら N を割る捜査をするという方向で実装していった。のちにこの方法は計算量的にも処理的にも無理があったのですが、最初は問題の理解もそんなに深くなかったのでこの方向で進んでいた。
コンテスト1時間経過したくらいから、この方針はもう無理だと感じ始め、あきらめかける。（家事やらがまだあったので…）
しかし、よくよく問題を見ていくと、素因数分解すると N = a^m × b^n × ... と表せること、m,n...を 1+2+3... と表現することが思い浮かび、以下のような方針で回答をした。

```txt
N を素因数分解して、2 次元配列で f = [[a,n],[b,m]...]として表現する。(a^n, + b^m ... )
それぞれの要素の２つ目の要素（m,n,...）をfor 文で -1 ,-2, -3...と 0 になるまで引いて行って、その回数をカウントする。
カウントを答えとして出力
```

ただ、この方針で N = 1 で WA となってしまい、コーナーケースで焦りましたが、サンプル再確認してACすることができた。
提出したコードは↓。

```py

def factorization(n):
    arr = []
    temp = n
    for i in range(2, int(-(-n**0.5//1))+1):
        if temp%i==0:
            cnt=0
            while temp%i==0:
                cnt+=1
                temp //= i
            arr.append([i, cnt])
    if temp!=1:
        arr.append([temp, 1])
    if arr==[]:
        arr.append([n, 1])
    return arr
N = int(input())
lis = factorization(N)
ans = 0
if N == 1:
    print(0)
    exit()
for i in lis:
    cnt = 1
    target = i[1]
    while target > 0:
        if target - cnt >= 0:
            ans += 1
        target -= cnt
        cnt+=1
print(ans)
```

## 計算量

Nを素因数分解するのに O(√N) , また 2^40 > 10^12 となるので、N <= 10^12 であれば間に合う、ということだと思われる。

## 参考

もともと素因数分解のライブラリを以前問題を解いたときに持っていたが、それにバグが見つかり結局ググって以下の記事を参考にしました。
[参考にした記事](https://qiita.com/snow67675476/items/e87ddb9285e27ea555f8)

## 感想

この問題を結構早く解けた人は水色パフォだったのっでちょっと残念だったのですが、いろいろ試行錯誤したことで回答にたどり着けたことを考えると実力はついてきているのかなぁ、と。
何はともあれ茶パフォ上位をコンテスト中に解けるのはうれしい！
